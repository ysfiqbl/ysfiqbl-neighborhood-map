$(document).ready(function() {
	/**
	 * Location model to hold location data
	 * @param {map} map google map object to draw the location
	 * @param {lat} lat latitude of the location
	 * @param {lng} lng longitude of the location
	 */
	function Location(map, lat, lng) {
		this.marker = new google.maps.Marker({
			position: new google.maps.LatLng(lat, lng),
			map: map,
			draggable: true,
		});

		this.title = '';
		this.address = ko.observable();
		this.checkinsCount = ko.observable();
		this.tipCount = ko.observable();
		this.usersCount = ko.observable();
	}
	Location.prototype.toJSON = function() {
		return {
			'title': this.title,
			'lat': this.marker.getPosition().lat(),
			'lng': this.marker.getPosition().lng()
		};
	}

	/**
	 * Model that represents a Foursquare request.
	 */
	function FoursquareRequest() {
		this.index = 'https://api.foursquare.com/v2';
		this.clientId = 'ERHT3FHFXMWICB0G4LBHE1GU51LFYBYP3JS0DJU2LPAZAXDR';
		this.clientSecret = '1HPXTVYASF2DDEHPPN14XHEQW0B2R1WI4GDY1MVMTYZN3XGK';
		this.version = '20130815';
		this.xhr;
	}
	(function() {
		this.search = function(params, callback) {
			var url = [this.index , 'venues', 'search'].join('/');
			var data = {
				'll': params.ll,
				'query': params.query,
				'radius': 50,
				'client_id': this.clientId,
				'client_secret': this.clientSecret,
				'v': this.version,
				'intent': 'browse'
			}
			if (this.xhr && this.xhr.readyState != 4) {
				this.xhr.abort();
				console.log('Aborted previous request');
			}
			this.xhr = $.get(url, data, callback.success, 'json');
			this.xhr.fail(callback.fail);
		};
	}).call(FoursquareRequest.prototype);

	var ViewModel = function() {
		var self = this;
		self.allLocations = []
		self.map;
		self.currentLocation = ko.observable({});
		self.infowindow = undefined;
		self.locationSearchQuery = ko.observable('');
		self.showAll = ko.observable(false);
		self.showListView = ko.observable(false);
		self.foursquareRequest = new FoursquareRequest();
		self.showInfo = ko.observable(false);
		self.showError = ko.observable(false);
		self.showLocationSuggestions = ko.observable(false);

		/**
		 * Provide search suggestions and filter the map markers based on the search query.
		 * @return {array}   Array containing search suggestions strings
		 */
		self.locationSearchSuggestions = ko.computed(function() {
			var query = self.locationSearchQuery().toLowerCase();
			var marker;
			if (query == '' && self.showListView() == true) {
				return ko.utils.arrayFilter(self.allLocations, function(loc) {
					loc.marker.setVisible(true);
					return true;
				});
			} else {
				return ko.utils.arrayFilter(self.allLocations, function(loc) {
					var result = loc.title.toLowerCase().indexOf(query) > -1;
					m = loc.marker;
					m.setVisible(result);
					if (self.infowindow != undefined && !result && self.infowindow.marker == m) {
						self.closeInfoWindow();
					}
					return result;
				});
			}
		});

		/**
		 * A computed observable that tracks whether the location search suggestion div should be shown or not.
		 * The location search suggestions are shown if
		 * The self.showLocationSuggestions observable is true
		 * The search query is not an empty string ''
		 * The locationsSearchSuggestions array has any elements it. i.e. the search query has matching suggestions.
		 *
		 * @return {show}   variable determines whether the location search suggestions are shown or not.
		 */
		self.showLocationSearchDiv = ko.computed(function() {
			var show = false;
			if  (self.showListView() == true) {
				show = true;
			} else if (self.showLocationSuggestions() === false) {
				show = false;
			} else if (self.locationSearchQuery() == '') {
				show = false;
			} else if (self.locationSearchSuggestions().length > 0) {
				show = true;
			} else {
				show = false;
			}
			return show;
		});

		/**
		 * Initialize the map.
		 */
		self.initialize = function() {
			self.mapOptions = {
				zoom: 16,
				center: new google.maps.LatLng(6.8412, 79.874),
				panControl: true,
				panControlOptions: {
					position: google.maps.ControlPosition.RIGHT_BOTTOM
				},
				zoomControl: true,
				zoomControlOptions: {
					style: google.maps.ZoomControlStyle.SMALL,
					position: google.maps.ControlPosition.RIGHT_BOTTOM
				}
			};
			self.map = new google.maps.Map(document.getElementById('map-canvas'), self.mapOptions);

			self.loadLocations();

			google.maps.event.addListener(self.map, 'click', function(event) {
				var loc = new Location(self.map, event.latLng.lat(), event.latLng.lng());
				self.addLocationEventListeners(loc);
				google.maps.event.trigger(loc.marker, 'click');
			});
		}

		google.maps.event.addDomListener(window, 'load', self.initialize);


		/**
		 * Set flag to indicate whether to show or hide the list.
		 */
		self.showList = function() {
			self.showListView(self.showListView() == true ? false : true);
		};

		/**
		 * Set the ko observable used to track whether the search suggestions should be shown to true.
		 * This function is triggered everytime the search input box is clicked and it is required since
		 * this observable is set to false to hide the div everytime a search suggestions is clicked. The
		 * observable is set to false in the self.showLocation function.
		 */
		self.initializeSearchText = function() {
			self.showLocationSuggestions(true);
		};

		/**
		 * Add event listeners to marker. Currently the click event is the only one that is being used
		 * @param {Location} loc Location to add the event listener to.
		 */
		self.addLocationEventListeners = function(loc) {
			google.maps.event.addListener(loc.marker, 'click', function() {
				self.currentLocation(loc);
				self.showInfoWindow();
				self.locationSearchQuery('');
			});
		};

		/**
		 * This function is called when the search button is clicked or a location title is selected
		 * from the search suggestions.
		 *
		 * Find the location and call the function to show the infor window.
		 *
		 * @param  {JSON object} loc Location to be searched.
		 */
		self.showLocation = function(loc) {
			self.currentLocation(loc);
			self.showInfoWindow();
		}

		/**
		 * Draw infowindow on map and assign listeners to it.
		 */
		self.showInfoWindow = function() {
			var loc = self.currentLocation();
			self.showInfo(false);
			self.showError(false);
			if (self.currentLocation().title != '') {
				var position = loc.marker.getPosition();
				self.foursquareRequest.search({
					'll': [position.lat(), position.lng()].join(','),
					'query': loc.title
				}, self.foursquareResponseHandler);
			}

			self.showLocationSuggestions(false);
			self.locationSearchQuery(loc.title);

			if (self.infowindow === undefined || self.infowindow.marker !== loc.marker) {
				if (self.infowindow !== undefined) {
					self.infowindow.close();
				}

				self.infowindow =  new google.maps.InfoWindow({
					content: document.getElementById('infowindow-template').innerHTML
				})
				self.infowindow.marker = loc.marker;
				self.infowindow.open(self.map, loc.marker);

				google.maps.event.addListener(self.infowindow, 'domready', function() {
					ko.applyBindings(self, document.getElementById('infowindow'));
				});

				google.maps.event.addListener(self.infowindow, 'closeclick', function() {
					self.infowindow = undefined;
					self.locationSearchQuery('');
				});
			}
		}

		/**
		 * Close the infowindow and set the infowindow variable to undefined.
		 */
		self.closeInfoWindow = function() {
			if (self.infowindow != undefined) {
				self.infowindow.close();
				self.infowindow = undefined;
			}
		}

		/**
		 * Create or update location in local storage and the allLocations array.
		 *
		 * If the index of location is greater than -1 then the location already
		 * exists in the self.allLocations therefore it will exist in the
		 * self.localStoreLocations array as well.
		 * Else the location is new and needs to be added to both the arrays.
		 *
		 * @param  {Location} loc Location to be added or updated.
		 */
		self.saveLocation = function() {
			var loc = self.currentLocation();
			var index = self.allLocations.indexOf(loc);
			if (index > -1) {
				self.allLocations[index] = loc;
			} else {
				self.allLocations.push(loc);
			}
			localStorage.locations = JSON.stringify(self.allLocations);
			self.closeInfoWindow();
		};

		/**
		 * Remove location from the map, self.allLocations array and local storage.
		 * The index of the location in the self.allLocations and self.localStoreLocations
		 * should be the same.
		 *
		 * @param  {Location} loc location to be removed
		 */
		self.removeLocation = function() {
			var loc = self.currentLocation();
			loc.marker.setMap(null);
			var index = self.allLocations.indexOf(loc);
			if (index > -1) {
				self.allLocations.splice(index, 1);
				localStorage.locations = JSON.stringify(self.allLocations);
				self.locationSearchQuery('');
			}
		};

		/**
		 * Draw previously saved locations on the screen and initialize the self.localStoreLocations
		 * and self.allLocations arrays.
		 *
		 * These locations are saved as a JSON string in the browsers localStorage.
		 */
		self.loadLocations = function() {
			if (localStorage.locations) {
				var localStoreLocations = JSON.parse(localStorage.locations);
				var locationJSON;
				var loc;
				for (var i = 0; i < localStoreLocations.length; i++) {
					locationJSON = localStoreLocations[i];
					loc = new Location(self.map, locationJSON.lat, locationJSON.lng);
					loc.title = locationJSON.title;
					self.addLocationEventListeners(loc);
					self.allLocations.push(loc);
				}
			}
		}

		/**
		 * Object to define the success and fail functions of the ajax GET calls.
		 *
		 * Poplate the address, tip count, check in count and user count of the current location if
		 * the response returned a non-emppty object.
		 *
		 * @param  {jQuery XHR Object} obj GET response object
		 */
		self.foursquareResponseHandler = {
			success: function(obj) {
				var venues = obj.response.venues;
				if ($.isEmptyObject(venues)) {
					self.currentLocation().address('n/a');
					self.currentLocation().checkinsCount('n/a');
					self.currentLocation().tipCount('n/a');
					self.currentLocation().usersCount('n/a');
				} else {
					var venue = venues[0];
					var stats = venue.stats;
					self.currentLocation().address(venue.location.formattedAddress.join(","));
					self.currentLocation().checkinsCount(stats.checkinsCount || 0);
					self.currentLocation().tipCount(stats.tipCount);
					self.currentLocation().usersCount(stats.usersCount);
				}
				self.showInfo(true);
			},
			fail: function() {
				self.showError(true);
			}
		}
	};

	ko.applyBindings(new ViewModel());
});